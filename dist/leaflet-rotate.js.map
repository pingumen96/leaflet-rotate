{"version":3,"file":"leaflet-rotate.js","sources":["../src/index.js","../src/geometry/Point.js","../src/dom/DomUtil.js","../src/dom/Draggable.js","../src/map/Map.js","../src/layer/DivOverlay.js","../src/layer/Popup.js","../src/layer/Tooltip.js","../src/layer/marker/Icon.js","../src/layer/marker/Marker.js","../src/layer/tile/GridLayer.js","../src/layer/vector/Renderer.js","../src/map/handler/CompassBearing.js","../src/map/handler/ContainerMutation.js","../src/map/handler/TouchGestures.js","../src/map/handler/TouchRotate.js","../src/map/handler/ShiftKeyRotate.js","../src/map/handler/TouchZoom.js","../src/control/Rotate.js"],"sourcesContent":["import { installPoint } from './geometry/Point';\r\nimport { installDomUtil } from './dom/DomUtil';\r\nimport { installDraggable } from './dom/Draggable';\r\nimport { installDivOverlay } from './layer/DivOverlay';\r\nimport { installPopup } from './layer/Popup';\r\nimport { installTooltip } from './layer/Tooltip';\r\nimport { installMarkerIcon } from './layer/marker/Icon';\r\nimport { installMarker } from './layer/marker/Marker';\r\nimport { installGridLayer } from './layer/tile/GridLayer';\r\nimport { installRenderer } from './layer/vector/Renderer';\r\nimport { installMap } from './map/Map';\r\nimport { installCompassBearing } from './map/handler/CompassBearing';\r\nimport { installContainerMutation } from './map/handler/ContainerMutation';\r\nimport { installTouchGestures } from './map/handler/TouchGestures';\r\nimport { installTouchRotate } from './map/handler/TouchRotate';\r\nimport { installShiftKeyRotate } from './map/handler/ShiftKeyRotate';\r\nimport { installTouchZoom } from './map/handler/TouchZoom';\r\nimport { installRotateControl } from './control/Rotate';\r\n\r\n/**\r\n * Apply the Leaflet-Rotate extensions to a provided Leaflet namespace.\r\n * The function returns the same namespace to enable chaining.\r\n *\r\n * @param {typeof L} L Leaflet namespace to extend.\r\n * @returns {typeof L}\r\n */\r\nexport function install(L) {\r\n    if (!L || typeof L !== 'object') {\r\n        throw new Error('Leaflet namespace required');\r\n    }\r\n\r\n    installPoint(L);\r\n    installDomUtil(L);\r\n    installDraggable(L);\r\n    installMap(L);\r\n    installDivOverlay(L);\r\n    installPopup(L);\r\n    installTooltip(L);\r\n    installMarkerIcon(L);\r\n    installMarker(L);\r\n    installGridLayer(L);\r\n    installRenderer(L);\r\n    installCompassBearing(L);\r\n    installContainerMutation(L);\r\n    installTouchGestures(L);\r\n    installTouchRotate(L);\r\n    installShiftKeyRotate(L);\r\n    installTouchZoom(L);\r\n    installRotateControl(L);\r\n\r\n    return L;\r\n}\r\n\r\nexport default { install };\r\n","/**\r\n * @external L.Point\r\n *\r\n * @see https://github.com/Leaflet/Leaflet/tree/v1.9.3/src/geometry/Point.js\r\n */\r\n\r\nexport function installPoint(L) {\r\n    if (!L.Point || L.Point.__leafletRotateInstalled) {\r\n        return;\r\n    }\r\n\r\n    L.extend(L.Point.prototype, {\r\n\r\n        /**\r\n         * Rotate around (0,0) by applying the 2D rotation matrix:\r\n         *\r\n         * ⎡ x' ⎤ = ⎡ cos θ  -sin θ ⎤ ⎡ x ⎤\r\n         * ⎣ y' ⎦   ⎣ sin θ   cos θ ⎦ ⎣ y ⎦\r\n         *\r\n         * @param theta must be given in radians.\r\n         */\r\n        rotate: function (theta) {\r\n            return this.rotateFrom(theta, new L.Point(0, 0));\r\n        },\r\n\r\n        /**\r\n         * Rotate around (pivot.x, pivot.y) by:\r\n         *\r\n         * 1. subtract (pivot.x, pivot.y)\r\n         * 2. rotate around (0, 0)\r\n         * 3. add (pivot.x, pivot.y) back\r\n         *\r\n         * same as `this.subtract(pivot).rotate(theta).add(pivot)`\r\n         *\r\n         * @param {Number} theta\r\n         * @param {L.Point} pivot\r\n         *\r\n         * @returns {L.Point}\r\n         */\r\n        rotateFrom: function (theta, pivot) {\r\n            if (!theta) { return this; }\r\n            var sinTheta = Math.sin(theta);\r\n            var cosTheta = Math.cos(theta);\r\n            var cx = pivot.x,\r\n                cy = pivot.y;\r\n            var x = this.x - cx,\r\n                y = this.y - cy;\r\n\r\n            return new L.Point(\r\n                x * cosTheta - y * sinTheta + cx,\r\n                x * sinTheta + y * cosTheta + cy\r\n            );\r\n        },\r\n\r\n    });\r\n\r\n    L.Point.__leafletRotateInstalled = true;\r\n}\r\n","/**\r\n * @external L.DomUtil\r\n *\r\n * @see https://github.com/Leaflet/Leaflet/tree/v1.9.3/src/dom/DomUtil.js\r\n */\r\n\r\nexport function installDomUtil(L) {\r\n    if (L.DomUtil && L.DomUtil.__leafletRotateInstalled) {\r\n        return;\r\n    }\r\n\r\n    const domUtilProto = L.extend({}, L.DomUtil);\r\n\r\n    L.extend(L.DomUtil, {\r\n\r\n        /**\r\n         * Resets the 3D CSS transform of `el` so it is\r\n         * translated by `offset` pixels and optionally\r\n         * scaled by `scale`. Does not have an effect if\r\n         * the browser doesn't support 3D CSS transforms.\r\n         *\r\n         * @param {HTMLElement} el\r\n         * @param {L.Point} offset\r\n         * @param {Number} scale\r\n         * @param {Number} bearing\r\n         * @param {L.Point} pivot\r\n         */\r\n        setTransform: function (el, offset, scale, bearing, pivot) {\r\n            var pos = offset || new L.Point(0, 0);\r\n\r\n            if (!bearing) {\r\n                offset = pos._round();\r\n                return domUtilProto.setTransform.apply(this, arguments);\r\n            }\r\n\r\n            pos = pos.rotateFrom(bearing, pivot);\r\n\r\n            el.style[L.DomUtil.TRANSFORM] =\r\n                'translate3d(' + pos.x + 'px,' + pos.y + 'px' + ',0)' +\r\n                (scale ? ' scale(' + scale + ')' : '') +\r\n                ' rotate(' + bearing + 'rad)';\r\n        },\r\n\r\n        /**\r\n         * Sets the position of `el` to coordinates specified by\r\n         * `position`, using CSS translate or top/left positioning\r\n         * depending on the browser (used by Leaflet internally\r\n         * to position its layers).\r\n         *\r\n         * @param {HTMLElement} el\r\n         * @param {L.Point} point\r\n         * @param {Number} bearing\r\n         * @param {L.Point} pivot\r\n         * @param {Number} scale\r\n         */\r\n        setPosition: function (el, point, bearing, pivot, scale) {\r\n            if (!bearing) {\r\n                return domUtilProto.setPosition.apply(this, arguments);\r\n            }\r\n\r\n            /*eslint-disable */\r\n            el._leaflet_pos = point;\r\n            /*eslint-enable */\r\n\r\n            if (L.Browser.any3d) {\r\n                L.DomUtil.setTransform(el, point, scale, bearing, pivot);\r\n            } else {\r\n                el.style.left = point.x + 'px';\r\n                el.style.top = point.y + 'px';\r\n            }\r\n        },\r\n\r\n        /**\r\n         * @constant radians = degrees × π/180°\r\n         */\r\n        DEG_TO_RAD: Math.PI / 180,\r\n\r\n        /**\r\n         * @constant degrees = radians × 180°/π\r\n         */\r\n        RAD_TO_DEG: 180 / Math.PI,\r\n\r\n    });\r\n\r\n    L.DomUtil.__leafletRotateInstalled = true;\r\n}\r\n","/**\r\n * @external L.Draggable\r\n *\r\n * @see https://github.com/Leaflet/Leaflet/tree/v1.9.3/src/dom/Draggable.js\r\n */\r\n\r\n/**\r\n * A class for making DOM elements draggable (including touch support).\r\n * Used internally for map and marker dragging. Only works for elements\r\n * that were positioned with [`L.DomUtil.setPosition`](#domutil-setposition).\r\n */\r\n\r\nexport function installDraggable(L) {\r\n    if (!L.Draggable || L.Draggable.__leafletRotateInstalled) {\r\n        return;\r\n    }\r\n\r\n    L.Draggable.include({\r\n\r\n        /** @TODO */\r\n        // updateMapBearing: function(mapBearing) {\r\n        //     this._mapBearing = mapBearing;\r\n        // },\r\n\r\n    });\r\n\r\n    L.Draggable.__leafletRotateInstalled = true;\r\n}","/**\r\n * @external L.Map\r\n *\r\n * @see https://github.com/Leaflet/Leaflet/blob/v1.9.3/src/map/Map.js\r\n */\r\n\r\nexport function installMap(L) {\r\n    if (!L.Map || L.Map.__leafletRotateInstalled) {\r\n        return;\r\n    }\r\n\r\n    const mapProto = L.extend({}, L.Map.prototype);\r\n\r\n    L.Map.mergeOptions({ rotate: false, bearing: 0, });\r\n\r\n    L.Map.include({\r\n\r\n        /**\r\n         * @param {(HTMLElement|String)} id html selector\r\n         * @param {Object} [options={}] leaflet map options\r\n         */\r\n        initialize: function (id, options) {\r\n            if (options.rotate) {\r\n                this._rotate = true;\r\n                this._bearing = 0;\r\n            }\r\n            mapProto.initialize.apply(this, arguments);\r\n            if (this.options.rotate) {\r\n                this.setBearing(this.options.bearing);\r\n            }\r\n        },\r\n\r\n        /**\r\n         * Given a pixel coordinate relative to the map container,\r\n         * returns the corresponding pixel coordinate relative to\r\n         * the [origin pixel](#map-getpixelorigin).\r\n         *\r\n         * @param {L.Point} point pixel screen coordinates\r\n         * @returns {L.Point} transformed pixel point\r\n         */\r\n        containerPointToLayerPoint: function (point) {\r\n            if (!this._rotate) {\r\n                return mapProto.containerPointToLayerPoint.apply(this, arguments);\r\n            }\r\n            return L.point(point)\r\n                .subtract(this._getMapPanePos())\r\n                .rotateFrom(-this._bearing, this._getRotatePanePos())\r\n                .subtract(this._getRotatePanePos());\r\n        },\r\n\r\n        /**\r\n         * Given a pixel coordinate relative to the [origin pixel](#map-getpixelorigin),\r\n         * returns the corresponding pixel coordinate relative to the map container.\r\n         *\r\n         * @param {L.Point} point pixel screen coordinates\r\n         * @returns {L.Point} transformed pixel point\r\n         */\r\n        layerPointToContainerPoint: function (point) {\r\n            if (!this._rotate) {\r\n                return mapProto.layerPointToContainerPoint.apply(this, arguments);\r\n            }\r\n            return L.point(point)\r\n                .add(this._getRotatePanePos())\r\n                .rotateFrom(this._bearing, this._getRotatePanePos())\r\n                .add(this._getMapPanePos());\r\n        },\r\n\r\n        /**\r\n         * Converts a coordinate from the rotated pane reference system\r\n         * to the reference system of the not rotated map pane.\r\n         *\r\n         * (rotatePane) --> (mapPane)\r\n         * (rotatePane) --> (norotatePane)\r\n         *\r\n         * @param {L.Point} point pixel screen coordinates\r\n         * @returns {L.Point}\r\n         *\r\n         * @since leaflet-rotate (v0.1)\r\n         */\r\n        rotatedPointToMapPanePoint: function (point) {\r\n            return L.point(point)\r\n                .rotate(this._bearing)\r\n                ._add(this._getRotatePanePos());\r\n        },\r\n\r\n        /**\r\n         * Converts a coordinate from the not rotated map pane reference system\r\n         * to the reference system of the rotated pane.\r\n         *\r\n         * (mapPane) --> (rotatePane)\r\n         * (norotatePane) --> (rotatePane)\r\n         *\r\n         * @param {L.Point} point pixel screen coordinates\r\n         *\r\n         * @since leaflet-rotate (v0.1)\r\n         */\r\n        mapPanePointToRotatedPoint: function (point) {\r\n            return L.point(point)\r\n                ._subtract(this._getRotatePanePos())\r\n                .rotate(-this._bearing);\r\n        },\r\n\r\n        // latLngToLayerPoint: function (latlng) {\r\n        //     var projectedPoint = this.project(L.latLng(latlng))._round();\r\n        //     return projectedPoint._subtract(this.getPixelOrigin());\r\n        // },\r\n\r\n        // latLngToContainerPoint: function (latlng) {\r\n        // \treturn this.layerPointToContainerPoint(this.latLngToLayerPoint(toLatLng(latlng)));\r\n        // },\r\n\r\n        /**\r\n         * Given latlng bounds, returns the bounds in projected pixel\r\n         * relative to the map container.\r\n         *\r\n         * @see https://github.com/ronikar/Leaflet/blob/5c480ef959b947c3beed7065425a5a36c486262b/src/map/Map.js#L1114-L1135\r\n         *\r\n         * @param {L.LatLngBounds} bounds\r\n         * @returns {L.Bounds}\r\n         *\r\n         * @since leaflet-rotate (v0.2)\r\n         */\r\n        mapBoundsToContainerBounds: function (bounds) {\r\n            if (!this._rotate && mapProto.mapBoundsToContainerBounds) {\r\n                return mapProto.mapBoundsToContainerBounds.apply(this, arguments);\r\n            }\r\n\r\n            // const nw = this.latLngToContainerPoint(bounds.getNorthWest()),\r\n            //       ne = this.latLngToContainerPoint(bounds.getNorthEast()),\r\n            //       sw = this.latLngToContainerPoint(bounds.getSouthWest()),\r\n            //       se = this.latLngToContainerPoint(bounds.getSouthEast());\r\n\r\n            // same as `this.latLngToContainerPoint(latlng)` but with floating point precision\r\n            const origin = this.getPixelOrigin();\r\n            const nw = this.layerPointToContainerPoint(this.project(bounds.getNorthWest())._subtract(origin)),\r\n                ne = this.layerPointToContainerPoint(this.project(bounds.getNorthEast())._subtract(origin)),\r\n                sw = this.layerPointToContainerPoint(this.project(bounds.getSouthWest())._subtract(origin)),\r\n                se = this.layerPointToContainerPoint(this.project(bounds.getSouthEast())._subtract(origin));\r\n\r\n            return L.bounds([\r\n                L.point(Math.min(nw.x, ne.x, se.x, sw.x), Math.min(nw.y, ne.y, se.y, sw.y)), // [ minX, minY ]\r\n                L.point(Math.max(nw.x, ne.x, se.x, sw.x), Math.max(nw.y, ne.y, se.y, sw.y))  // [ maxX, maxY ]\r\n            ]);\r\n        },\r\n\r\n        /**\r\n         * Returns geographical bounds visible in the current map view\r\n         *\r\n         * @TODO find out  if map bounds calculated by `L.Map::getBounds()`\r\n         *       function should match the `rotatePane` or `norotatePane` bounds\r\n         *\r\n         * @see https://github.com/fnicollet/Leaflet/issues/7\r\n         *\r\n         * @returns {L.LatLngBounds}\r\n         */\r\n        getBounds: function () {\r\n            if (!this._rotate) {\r\n                return mapProto.getBounds.apply(this, arguments);\r\n            }\r\n\r\n            // SEE: https://github.com/fnicollet/Leaflet/pull/22\r\n            //\r\n            // var bounds = this.getPixelBounds(),\r\n            // sw = this.unproject(bounds.getBottomLeft()),\r\n            // ne = this.unproject(bounds.getTopRight());\r\n            // return new LatLngBounds(sw, ne);\r\n            //\r\n\r\n            // LatLngBounds' constructor automatically\r\n            // extends the bounds to fit the passed points\r\n            var size = this.getSize();\r\n            return new L.LatLngBounds([\r\n                this.containerPointToLatLng([0, 0]),           // topleft\r\n                this.containerPointToLatLng([size.x, 0]),      // topright\r\n                this.containerPointToLatLng([size.x, size.y]), // bottomright\r\n                this.containerPointToLatLng([0, size.y]),      // bottomleft\r\n            ]);\r\n        },\r\n\r\n        /**\r\n         * Returns the bounds of the current map view in projected pixel\r\n         * coordinates (sometimes useful in layer and overlay implementations).\r\n         *\r\n         * @TODO find out if map bounds calculated by `L.Map::getPixelBounds()`\r\n         *       function should match the `rotatePane` or `norotatePane` bounds\r\n         *\r\n         * @see https://github.com/fnicollet/Leaflet/issues/7\r\n         *\r\n         * @returns {L.Bounds}\r\n         */\r\n        // getPixelBounds(center, zoom) {\r\n        //     // const topLeftPoint = map.containerPointToLayerPoint(this._getTopLeftPoint());\r\n        //     const topLeftPoint = this._getTopLeftPoint(center, zoom);\r\n        //       return new L.Bounds(topLeftPoint, topLeftPoint.add(this.getSize()));\r\n        // },\r\n\r\n        /**\r\n         * Change map rotation\r\n         *\r\n         * @param {number} theta map degrees\r\n         *\r\n         * @since leaflet-rotate (v0.1)\r\n         */\r\n        setBearing: function (theta) {\r\n            if (!L.Browser.any3d || !this._rotate) { return; }\r\n\r\n            var bearing = L.Util.wrapNum(theta, [0, 360]) * L.DomUtil.DEG_TO_RAD,\r\n                center = this._getPixelCenter(),\r\n                oldPos = this._getRotatePanePos().rotateFrom(-this._bearing, center),\r\n                newPos = oldPos.rotateFrom(bearing, center);\r\n\r\n            // CSS transform\r\n            L.DomUtil.setPosition(this._rotatePane, oldPos, bearing, center);\r\n\r\n            this._pivot = center;\r\n            this._bearing = bearing;\r\n            this._rotatePanePos = newPos;\r\n\r\n            this.fire('rotate');\r\n        },\r\n\r\n        /**\r\n         * Get current map rotation\r\n         *\r\n         * @returns {number} theta map degrees\r\n         *\r\n         * @since leaflet-rotate (v0.1)\r\n         */\r\n        getBearing: function () {\r\n            return this._bearing * L.DomUtil.RAD_TO_DEG;\r\n        },\r\n\r\n        /**\r\n         * Creates a new [map pane](#map-pane) with the given name if it doesn't\r\n         * exist already, then returns it. The pane is created as a child of\r\n         * `container`, or as a child of the main map pane if not set.\r\n         *\r\n         * @param {String} name leaflet pane\r\n         * @param {HTMLElement} [container] parent element\r\n         * @returns {HTMLElement} pane container\r\n         */\r\n        // createPane: function(name, container) {\r\n        //     if (!this._rotate || name == 'mapPane') {\r\n        //         return mapProto.createPane.apply(this, arguments);\r\n        //     }\r\n        //     // init \"rotatePane\"\r\n        //     if (!this._rotatePane) {\r\n        //         // this._pivot = this.getSize().divideBy(2);\r\n        //         this._rotatePane = mapProto.createPane.call(this, 'rotatePane', this._mapPane);\r\n        //         L.DomUtil.setPosition(this._rotatePane, new L.Point(0, 0), this._bearing, this._pivot);\r\n        //     }\r\n        //     return mapProto.createPane.call(this, name, container || this._rotatePane);\r\n        // },\r\n\r\n        /**\r\n         * Panes are DOM elements used to control the ordering of layers on\r\n         * the map. You can access panes with [`map.getPane`](#map-getpane)\r\n         * or [`map.getPanes`](#map-getpanes) methods. New panes can be created\r\n         * with the [`map.createPane`](#map-createpane) method.\r\n         *\r\n         * Every map has the following default panes that differ only in zIndex:\r\n         *\r\n         * - mapPane     [HTMLElement = 'auto'] - Pane that contains all other map panes\r\n         * - tilePane    [HTMLElement = 2]      - Pane for tile layers\r\n         * - overlayPane [HTMLElement = 4]      - Pane for overlays like polylines and polygons\r\n         * - shadowPane  [HTMLElement = 5]      - Pane for overlay shadows (e.g. marker shadows)\r\n         * - markerPane  [HTMLElement = 6]      - Pane for marker icons\r\n         * - tooltipPane [HTMLElement = 650]    - Pane for tooltips.\r\n         * - popupPane   [HTMLElement = 700]    - Pane for popups.\r\n         */\r\n        _initPanes: function () {\r\n            var panes = this._panes = {};\r\n            this._paneRenderers = {};\r\n\r\n            this._mapPane = this.createPane('mapPane', this._container);\r\n            L.DomUtil.setPosition(this._mapPane, new L.Point(0, 0));\r\n\r\n            if (this._rotate) {\r\n                this._rotatePane = this.createPane('rotatePane', this._mapPane);\r\n                this._norotatePane = this.createPane('norotatePane', this._mapPane);\r\n                // rotatePane\r\n                this.createPane('tilePane', this._rotatePane);\r\n                this.createPane('overlayPane', this._rotatePane);\r\n                // norotatePane\r\n                this.createPane('shadowPane', this._norotatePane);\r\n                this.createPane('markerPane', this._norotatePane);\r\n                this.createPane('tooltipPane', this._norotatePane);\r\n                this.createPane('popupPane', this._norotatePane);\r\n            } else {\r\n                this.createPane('tilePane');\r\n                this.createPane('overlayPane');\r\n                this.createPane('shadowPane');\r\n                this.createPane('markerPane');\r\n                this.createPane('tooltipPane');\r\n                this.createPane('popupPane');\r\n            }\r\n\r\n            if (!this.options.markerZoomAnimation) {\r\n                L.DomUtil.addClass(panes.markerPane, 'leaflet-zoom-hide');\r\n                L.DomUtil.addClass(panes.shadowPane, 'leaflet-zoom-hide');\r\n            }\r\n        },\r\n\r\n        /**\r\n         * Pans the map the minimum amount to make the `latlng` visible. Use\r\n         * padding options to fit the display to more restricted bounds.\r\n         * If `latlng` is already within the (optionally padded) display bounds,\r\n         * the map will not be panned.\r\n         *\r\n         * @see https://github.com/Raruto/leaflet-rotate/issues/18\r\n         *\r\n         * @param {L.LatLng} latlng coordinates\r\n         * @param {Object} [options={}] padding options\r\n         *\r\n         * @returns {L.Map} current map instance\r\n         */\r\n        panInside(latlng, options) {\r\n            if (!this._rotate || Math.abs(this._bearing).toFixed(1) < 0.1) {\r\n                return mapProto.panInside.apply(this, arguments);\r\n            }\r\n\r\n            options = options || {};\r\n\r\n            const paddingTL = L.point(options.paddingTopLeft || options.padding || [0, 0]),\r\n                paddingBR = L.point(options.paddingBottomRight || options.padding || [0, 0]),\r\n                /** @TODO use mapProto.panInside */\r\n                // pixelPoint = this.project(latlng),\r\n                // pixelBounds = this.getPixelBounds(),\r\n                // pixelCenter = this.project(this.getCenter()),\r\n                rect = this._container.getBoundingClientRect(),\r\n                pixelPoint = this.latLngToContainerPoint(latlng),\r\n                pixelBounds = L.bounds([L.point(rect), L.point(rect).add(this.getSize())]),\r\n                pixelCenter = pixelBounds.getCenter(),\r\n                //\r\n                paddedBounds = L.bounds([pixelBounds.min.add(paddingTL), pixelBounds.max.subtract(paddingBR)]),\r\n                paddedSize = paddedBounds.getSize();\r\n\r\n            if (!paddedBounds.contains(pixelPoint)) {\r\n                this._enforcingBounds = true;\r\n                const centerOffset = pixelPoint.subtract(paddedBounds.getCenter());\r\n                const offset = paddedBounds.extend(pixelPoint).getSize().subtract(paddedSize);\r\n                pixelCenter.x += centerOffset.x < 0 ? -offset.x : offset.x;\r\n                pixelCenter.y += centerOffset.y < 0 ? -offset.y : offset.y;\r\n                /** @TODO use mapProto.panInside */\r\n                // this.panTo(this.unproject(pixelCenter), options);\r\n                this.panTo(this.containerPointToLatLng(pixelCenter), options);\r\n                //\r\n                this._enforcingBounds = false;\r\n            }\r\n            return this;\r\n        },\r\n\r\n        /**\r\n         * Pans the map to the closest view that would lie inside the given bounds\r\n         * (if it's not already), controlling the animation using the options specific,\r\n         * if any.\r\n         *\r\n         * @TODO check if map bounds calculated by `L.Map::panInsideBounds()`\r\n         *       function should match the `rotatePane` or `norotatePane` bounds\r\n         *\r\n         * @see https://github.com/fnicollet/Leaflet/issues/7\r\n         *\r\n         * @param {L.LatLngBounds} bounds coordinates\r\n         * @param {Object} [options] pan options\r\n         * @returns {L.Map} current map instance\r\n         */\r\n        // panInsideBounds: function (bounds, options) {\r\n        //     this._enforcingBounds = true;\r\n        //     var center = this.getCenter(),\r\n        //         newCenter = this._limitCenter(center, this._zoom, L.latLngBounds(bounds));\r\n        //\r\n        //     if (!center.equals(newCenter)) {\r\n        //         this.panTo(newCenter, options);\r\n        //     }\r\n        //\r\n        //     this._enforcingBounds = false;\r\n        //     return this;\r\n        // },\r\n\r\n        // adjust center for view to get inside bounds\r\n        // _limitCenter(center, zoom, bounds) {\r\n        //\r\n        //     if (!bounds) { return center; }\r\n        //\r\n        //     const centerPoint = this.project(center, zoom),\r\n        //         viewHalf = this.getSize().divideBy(2),\r\n        //         viewBounds = new Bounds(centerPoint.subtract(viewHalf), centerPoint.add(viewHalf)),\r\n        //         offset = this._getBoundsOffset(viewBounds, bounds, zoom);\r\n        //\r\n        //     // If offset is less than a pixel, ignore.\r\n        //     // This prevents unstable projections from getting into\r\n        //     // an infinite loop of tiny offsets.\r\n        //     if (Math.abs(offset.x) <= 1 && Math.abs(offset.y) <= 1) {\r\n        //             return center;\r\n        //     }\r\n        //\r\n        //     return this.unproject(centerPoint.add(offset), zoom);\r\n        // },\r\n\r\n        // @method flyToBounds(bounds: LatLngBounds, options?: fitBounds options): this\r\n        // Sets the view of the map with a smooth animation like [`flyTo`](#map-flyto),\r\n        // but takes a bounds parameter like [`fitBounds`](#map-fitbounds).\r\n        // flyToBounds(bounds, options) {\r\n        //     const target = this._getBoundsCenterZoom(bounds, options);\r\n        //     return this.flyTo(target.center, target.zoom, options);\r\n        // },\r\n\r\n        // _getBoundsCenterZoom(bounds, options) {\r\n        //\r\n        //     options = options || {};\r\n        //     bounds = bounds.getBounds ? bounds.getBounds() : toLatLngBounds(bounds);\r\n        //\r\n        //     const paddingTL = L.point(options.paddingTopLeft || options.padding || [0, 0]),\r\n        //           paddingBR = L.point(options.paddingBottomRight || options.padding || [0, 0]);\r\n        //\r\n        //     let zoom = this.getBoundsZoom(bounds, false, paddingTL.add(paddingBR));\r\n        //\r\n        //     zoom = (typeof options.maxZoom === 'number') ? Math.min(options.maxZoom, zoom) : zoom;\r\n        //\r\n        //     if (zoom === Infinity) {\r\n        //         return { center: bounds.getCenter(), zoom };\r\n        //     }\r\n        //\r\n        //     return { center, zoom };\r\n        //\r\n        // },\r\n\r\n        /**\r\n         * Returns the maximum zoom level on which the given bounds fit to the map\r\n         * view in its entirety. If `inside` (optional) is set to `true`, the method\r\n         * instead returns the minimum zoom level on which the map view fits into\r\n         * the given bounds in its entirety.\r\n         *\r\n         * @param {L.LatLngBounds} bounds\r\n         * @param {Boolean} [inside=false]\r\n         * @param {L.Point} [padding=[0,0]]\r\n         *\r\n         * @returns {Number} zoom level\r\n         */\r\n        getBoundsZoom(bounds, inside, padding) {\r\n            if (!this._rotate || Math.abs(this._bearing).toFixed(1) < 0.1) {\r\n                return mapProto.getBoundsZoom.apply(this, arguments);\r\n            }\r\n\r\n            bounds = L.latLngBounds(bounds);\r\n            padding = L.point(padding || [0, 0]);\r\n\r\n            let zoom = this.getZoom() || 0;\r\n            const min = this.getMinZoom(),\r\n                max = this.getMaxZoom(),\r\n                /** @TODO use mapProto.getBoundsZoom */\r\n                // nw = bounds.getNorthWest(),\r\n                // se = bounds.getSouthEast(),\r\n                // size = this.getSize().subtract(padding),\r\n                // boundsSize = L.bounds(this.project(se, zoom), this.project(nw, zoom)).getSize(),\r\n                size = this.getSize().subtract(padding),\r\n                boundsSize = this.mapBoundsToContainerBounds(bounds).getSize(),\r\n                snap = this.options.zoomSnap,\r\n                scalex = size.x / boundsSize.x,\r\n                scaley = size.y / boundsSize.y,\r\n                scale = inside ? Math.max(scalex, scaley) : Math.min(scalex, scaley);\r\n\r\n            zoom = this.getScaleZoom(scale, zoom);\r\n\r\n            if (snap) {\r\n                zoom = Math.round(zoom / (snap / 100)) * (snap / 100); // don't jump if within 1% of a snap level\r\n                zoom = inside ? Math.ceil(zoom / snap) * snap : Math.floor(zoom / snap) * snap;\r\n            }\r\n\r\n            return Math.max(min, Math.min(max, zoom));\r\n        },\r\n\r\n        /**\r\n         * Layer point of the current center\r\n         *\r\n         * @returns {L.Point} layer center\r\n         */\r\n        // _getCenterLayerPoint: function () {\r\n        //    return this.containerPointToLayerPoint(this.getSize()._divideBy(2));\r\n        // },\r\n\r\n        /**\r\n         * Offset of the specified place to the current center in pixels\r\n         *\r\n         * @param {L.LatLng} latlng map coordinates\r\n         */\r\n        _getCenterOffset: function (latlng) {\r\n            var centerOffset = mapProto._getCenterOffset.apply(this, arguments);\r\n            if (this._rotate) {\r\n                centerOffset = centerOffset.rotate(this._bearing);\r\n            }\r\n            return centerOffset;\r\n        },\r\n\r\n        /**\r\n         * @since leaflet-rotate (v0.1)\r\n         */\r\n        _getRotatePanePos: function () {\r\n            return this._rotatePanePos || new L.Point(0, 0);\r\n            // return L.DomUtil.getPosition(this._rotatePane) || new L.Point(0, 0);\r\n        },\r\n\r\n        // _latLngToNewLayerPoint(latlng, zoom, center) {\r\n        //    const topLeft = this._getNewPixelOrigin(center, zoom);\r\n        //    return this.project(latlng, zoom)._subtract(topLeft);\r\n        //},\r\n\r\n        _getNewPixelOrigin: function (center, zoom) {\r\n            if (!this._rotate) {\r\n                return mapProto._getNewPixelOrigin.apply(this, arguments);\r\n            }\r\n            var viewHalf = this.getSize()._divideBy(2);\r\n            return this.project(center, zoom)\r\n                .rotate(this._bearing)\r\n                ._subtract(viewHalf)\r\n                ._add(this._getMapPanePos())\r\n                ._add(this._getRotatePanePos())\r\n                .rotate(-this._bearing)\r\n                ._round();\r\n        },\r\n\r\n        /**\r\n         * @since leaflet-rotate (v0.2)\r\n         *\r\n         * @see src\\layer\\tile\\GridLayer::_getTiledPixelBounds()\r\n         */\r\n        _getNewPixelBounds: function (center, zoom) {\r\n            center = center || this.getCenter();\r\n            zoom = zoom || this.getZoom();\r\n            if (!this._rotate && mapProto._getNewPixelBounds) {\r\n                return mapProto._getNewPixelBounds.apply(this, arguments);\r\n            }\r\n            var mapZoom = this._animatingZoom ? Math.max(this._animateToZoom, this.getZoom()) : this.getZoom(),\r\n                scale = this.getZoomScale(mapZoom, zoom),\r\n                pixelCenter = this.project(center, zoom).floor(),\r\n                size = this.getSize(),\r\n                halfSize = new L.Bounds([\r\n                    this.containerPointToLayerPoint([0, 0]).floor(),\r\n                    this.containerPointToLayerPoint([size.x, 0]).floor(),\r\n                    this.containerPointToLayerPoint([0, size.y]).floor(),\r\n                    this.containerPointToLayerPoint([size.x, size.y]).floor()\r\n                ]).getSize().divideBy(scale * 2);\r\n\r\n            return new L.Bounds(pixelCenter.subtract(halfSize), pixelCenter.add(halfSize));\r\n        },\r\n\r\n        /**\r\n         * @since leaflet-rotate (v0.2)\r\n         *\r\n         * @return {L.Point} map pivot point (center)\r\n         */\r\n        _getPixelCenter: function () {\r\n            if (!this._rotate && mapProto._getPixelCenter) {\r\n                return mapProto._getPixelCenter.apply(this, arguments);\r\n            }\r\n            return this.getSize()._divideBy(2)._subtract(this._getMapPanePos());\r\n        },\r\n\r\n        /**\r\n         * @since leaflet-rotate (v0.2)\r\n         *\r\n         * @see src\\layer\\vector\\Renderer::_update()\r\n         */\r\n        _getPaddedPixelBounds: function (padding) {\r\n            if (!this._rotate && mapProto._getPaddedPixelBounds) {\r\n                return mapProto._getPaddedPixelBounds.apply(this, arguments);\r\n            }\r\n            var p = padding,\r\n                size = this.getSize(),\r\n                padMin = size.multiplyBy(-p),\r\n                padMax = size.multiplyBy(1 + p);\r\n            //min = this.containerPointToLayerPoint(size.multiplyBy(-p)).round();\r\n\r\n            return new L.Bounds([\r\n                this.containerPointToLayerPoint([padMin.x, padMin.y]).floor(),\r\n                this.containerPointToLayerPoint([padMin.x, padMax.y]).floor(),\r\n                this.containerPointToLayerPoint([padMax.x, padMin.y]).floor(),\r\n                this.containerPointToLayerPoint([padMax.x, padMax.y]).floor()\r\n            ]);\r\n        },\r\n\r\n        _handleGeolocationResponse: function (pos) {\r\n            if (!this._container._leaflet_id) { return; }\r\n\r\n            var lat = pos.coords.latitude,\r\n                lng = pos.coords.longitude,\r\n                /** @TODO use mapProto._handleGeolocationResponse */\r\n                hdg = pos.coords.heading,\r\n                latlng = new L.LatLng(lat, lng),\r\n                bounds = latlng.toBounds(pos.coords.accuracy),\r\n                options = this._locateOptions;\r\n\r\n            if (options.setView) {\r\n                var zoom = this.getBoundsZoom(bounds);\r\n                this.setView(latlng, options.maxZoom ? Math.min(zoom, options.maxZoom) : zoom);\r\n            }\r\n\r\n            var data = {\r\n                latlng: latlng,\r\n                bounds: bounds,\r\n                timestamp: pos.timestamp,\r\n                /** @TODO use mapProto._handleGeolocationResponse */\r\n                heading: hdg\r\n            };\r\n\r\n            for (var i in pos.coords) {\r\n                if (typeof pos.coords[i] === 'number') {\r\n                    data[i] = pos.coords[i];\r\n                }\r\n            }\r\n\r\n            // @event locationfound: LocationEvent\r\n            // Fired when geolocation (using the [`locate`](#map-locate) method)\r\n            // went successfully.\r\n            this.fire('locationfound', data);\r\n        },\r\n\r\n        /**\r\n         * @see https://github.com/ronikar/Leaflet/blob/5c480ef959b947c3beed7065425a5a36c486262b/src/geo/LatLngBounds.js#L253-L264\r\n         *\r\n         * @param {L.Bounds} points\r\n         * @returns {L.Bounds}\r\n         */\r\n        // toCircumscribedBounds(points) {\r\n        //     var minX = points.reduce(function (pv, v) { return Math.min(pv, v.x); }, points[0].x),\r\n        //         maxX = points.reduce(function (pv, v) { return Math.max(pv, v.x); }, points[0].x),\r\n        //         minY = points.reduce(function (pv, v) { return Math.min(pv, v.y); }, points[0].y),\r\n        //         maxY = points.reduce(function (pv, v) { return Math.max(pv, v.y); }, points[0].y);\r\n        //\r\n        //     return L.bounds(L.point(minX, minY), L.point(maxX, maxY));\r\n        // },\r\n\r\n    });\r\n\r\n    L.Map.__leafletRotateInstalled = true;\r\n}\r\n","/**\r\n * @external L.DivOverlay\r\n *\r\n * @see https://github.com/Leaflet/Leaflet/tree/v1.9.3/src/layer/DivOverlay.js\r\n */\r\n\r\nexport function installDivOverlay(L) {\r\n    if (!L.DivOverlay || L.DivOverlay.__leafletRotateInstalled) {\r\n        return;\r\n    }\r\n\r\n    const divOverlayProto = L.extend({}, L.DivOverlay.prototype);\r\n\r\n    L.DivOverlay.include({\r\n\r\n        /**\r\n         * Update L.Popup and L.Tooltip anchor positions after\r\n         * the map is moved by calling `map.setBearing(theta)`\r\n         *\r\n         * @listens L.Map~rotate\r\n         */\r\n        getEvents: function () {\r\n            return L.extend(divOverlayProto.getEvents.apply(this, arguments), { rotate: this._updatePosition });\r\n        },\r\n\r\n        /**\r\n         * 0. update element anchor point (divOverlayProto v1.9.3)\r\n         * 1. rotate around anchor point (subtract anchor -> rotate point -> add anchor)\r\n         */\r\n        _updatePosition: function () {\r\n            if (!this._map) { return; }\r\n            divOverlayProto._updatePosition.apply(this, arguments);\r\n            if (this._map && this._map._rotate && this._zoomAnimated) {\r\n                var anchor = this._getAnchor();\r\n                var pos = L.DomUtil.getPosition(this._container).subtract(anchor);\r\n                L.DomUtil.setPosition(this._container, this._map.rotatedPointToMapPanePoint(pos).add(anchor));\r\n            }\r\n\r\n        },\r\n\r\n    });\r\n\r\n    L.DivOverlay.__leafletRotateInstalled = true;\r\n}\r\n","/**\r\n * @external L.Popup\r\n *\r\n * @see https://github.com/Leaflet/Leaflet/tree/v1.9.3/src/layer/Popup.js\r\n */\r\n\r\nexport function installPopup(L) {\r\n    if (!L.Popup || L.Popup.__leafletRotateInstalled) {\r\n        return;\r\n    }\r\n\r\n    const popupProto = L.extend({}, L.Popup.prototype);\r\n\r\n    L.Popup.include({\r\n\r\n        /**\r\n         * 0. update element anchor point (popupProto v1.9.3)\r\n         * 1. rotate around anchor point (subtract anchor -> rotate point -> add anchor)\r\n         */\r\n        _animateZoom: function (e) {\r\n            popupProto._animateZoom.apply(this, arguments);\r\n            if (this._map && this._map._rotate) {\r\n                var anchor = this._getAnchor();\r\n                var pos = L.DomUtil.getPosition(this._container).subtract(anchor);\r\n                L.DomUtil.setPosition(this._container, this._map.rotatedPointToMapPanePoint(pos).add(anchor));\r\n            }\r\n        },\r\n\r\n        /**\r\n         * Fix for L.popup({ keepInView = true })\r\n         *\r\n         * @see https://github.com/fnicollet/Leaflet/pull/21\r\n         */\r\n        _adjustPan: function () {\r\n            if (!this.options.autoPan || (this._map._panAnim && this._map._panAnim._inProgress)) { return; }\r\n\r\n            // We can endlessly recurse if keepInView is set and the view resets.\r\n            // Let's guard against that by exiting early if we're responding to our own autopan.\r\n            if (this._autopanning) {\r\n                this._autopanning = false;\r\n                return;\r\n            }\r\n\r\n            var map = this._map,\r\n                marginBottom = parseInt(L.DomUtil.getStyle(this._container, 'marginBottom'), 10) || 0,\r\n                containerHeight = this._container.offsetHeight + marginBottom,\r\n                containerWidth = this._containerWidth,\r\n                layerPos = new L.Point(this._containerLeft, -containerHeight - this._containerBottom);\r\n\r\n            layerPos._add(L.DomUtil.getPosition(this._container));\r\n\r\n            /** @TODO use popupProto._adjustPan */\r\n            // var containerPos = map.layerPointToContainerPoint(layerPos);\r\n            var containerPos = layerPos._add(this._map._getMapPanePos()),\r\n                padding = L.point(this.options.autoPanPadding),\r\n                paddingTL = L.point(this.options.autoPanPaddingTopLeft || padding),\r\n                paddingBR = L.point(this.options.autoPanPaddingBottomRight || padding),\r\n                size = map.getSize(),\r\n                dx = 0,\r\n                dy = 0;\r\n\r\n            if (containerPos.x + containerWidth + paddingBR.x > size.x) { // right\r\n                dx = containerPos.x + containerWidth - size.x + paddingBR.x;\r\n            }\r\n            if (containerPos.x - dx - paddingTL.x < 0) { // left\r\n                dx = containerPos.x - paddingTL.x;\r\n            }\r\n            if (containerPos.y + containerHeight + paddingBR.y > size.y) { // bottom\r\n                dy = containerPos.y + containerHeight - size.y + paddingBR.y;\r\n            }\r\n            if (containerPos.y - dy - paddingTL.y < 0) { // top\r\n                dy = containerPos.y - paddingTL.y;\r\n            }\r\n\r\n            // @namespace Map\r\n            // @section Popup events\r\n            // @event autopanstart: Event\r\n            // Fired when the map starts autopanning when opening a popup.\r\n            if (dx || dy) {\r\n                // Track that we're autopanning, as this function will be re-ran on moveend\r\n                if (this.options.keepInView) {\r\n                    this._autopanning = true;\r\n                }\r\n                map\r\n                    .fire('autopanstart')\r\n                    .panBy([dx, dy]);\r\n            }\r\n        },\r\n\r\n    });\r\n\r\n    L.Popup.__leafletRotateInstalled = true;\r\n}\r\n","/**\r\n * @external L.Tooltip\r\n *\r\n * @see https://github.com/Leaflet/Leaflet/tree/v1.9.3/src/layer/Tooltip.js\r\n */\r\n\r\nexport function installTooltip(L) {\r\n    if (!L.Tooltip || L.Tooltip.__leafletRotateInstalled) {\r\n        return;\r\n    }\r\n\r\n    const tooltipProto = L.extend({}, L.Tooltip.prototype);\r\n\r\n    L.Tooltip.include({\r\n\r\n        _animateZoom: function (e) {\r\n            if (!this._map._rotate) {\r\n                return tooltipProto._animateZoom.apply(this, arguments);\r\n            }\r\n            var pos = this._map._latLngToNewLayerPoint(this._latlng, e.zoom, e.center);\r\n\r\n            pos = this._map.rotatedPointToMapPanePoint(pos);\r\n            this._setPosition(pos);\r\n        },\r\n\r\n        _updatePosition: function () {\r\n            if (!this._map._rotate) {\r\n                return tooltipProto._updatePosition.apply(this, arguments);\r\n            }\r\n            var pos = this._map.latLngToLayerPoint(this._latlng);\r\n\r\n            pos = this._map.rotatedPointToMapPanePoint(pos);\r\n            this._setPosition(pos);\r\n        },\r\n\r\n    });\r\n\r\n    L.Tooltip.__leafletRotateInstalled = true;\r\n}\r\n","/**\r\n * @external L.Icon\r\n *\r\n * @see https://github.com/Leaflet/Leaflet/tree/v1.9.3/src/layer/marker/Icon.js\r\n */\r\n\r\nexport function installMarkerIcon(L) {\r\n    if (!L.Icon || L.Icon.__leafletRotateInstalled) {\r\n        return;\r\n    }\r\n\r\n    const iconProto = L.extend({}, L.Icon.prototype);\r\n\r\n    L.Icon.include({\r\n\r\n        _setIconStyles: function (img, name) {\r\n            var options = this.options;\r\n            var sizeOption = options[name + 'Size'];\r\n\r\n            if (typeof sizeOption === 'number') {\r\n                sizeOption = [sizeOption, sizeOption];\r\n            }\r\n\r\n            var size = L.point(sizeOption),\r\n                anchor = L.point(name === 'shadow' && options.shadowAnchor || options.iconAnchor ||\r\n                    size && size.divideBy(2, true));\r\n\r\n            img.className = 'leaflet-marker-' + name + ' ' + (options.className || '');\r\n\r\n            if (anchor) {\r\n                img.style.marginLeft = (-anchor.x) + 'px';\r\n                img.style.marginTop = (-anchor.y) + 'px';\r\n                /** @TODO use iconProto._setIconStyles */\r\n                img.style[L.DomUtil.TRANSFORM + \"Origin\"] = anchor.x + \"px \" + anchor.y + \"px 0px\";\r\n            }\r\n\r\n            if (size) {\r\n                img.style.width = size.x + 'px';\r\n                img.style.height = size.y + 'px';\r\n            }\r\n        },\r\n\r\n    });\r\n\r\n    L.Icon.__leafletRotateInstalled = true;\r\n}\r\n","/**\r\n * @external L.Marker\r\n * @external L.Handler.MarkerDrag\r\n *\r\n * @see https://github.com/Leaflet/Leaflet/tree/v1.9.3/src/layer/marker/Marker.js\r\n * @see https://github.com/Leaflet/Leaflet/tree/v1.9.3/src/layer/marker/Marker.Drag.js\r\n * @see https://github.com/Leaflet/Leaflet/tree/v1.9.3/src/dom/Draggable.js\r\n */\r\n\r\nexport function installMarker(L) {\r\n    if (!L.Marker || L.Marker.__leafletRotateInstalled) {\r\n        return;\r\n    }\r\n\r\n    const markerProto = L.extend({}, L.Marker.prototype);\r\n\r\n    L.Marker.mergeOptions({\r\n\r\n        /**\r\n         * Rotation of this marker in rad\r\n         *\r\n         * @type {Number}\r\n         */\r\n        rotation: 0,\r\n\r\n        /**\r\n         * Rotate this marker when map rotates\r\n         *\r\n         * @type {Boolean}\r\n         */\r\n        rotateWithView: false,\r\n\r\n        /**\r\n         * Scale of the marker icon\r\n         *\r\n         * @type {Number}\r\n         */\r\n        scale: undefined,\r\n\r\n    });\r\n\r\n    var markerDragProto; // retrived at runtime (see below: L.Marker::_initInteraction())\r\n\r\n    var MarkerDrag = {\r\n\r\n        // _onDragStart: function() {\r\n        //     if (!this._marker._map._rotate) {\r\n        //         return markerDragProto._onDragStart.apply(this, arguments);\r\n        //     }\r\n        //     this._draggable.updateMapBearing(this._marker._map._bearing);\r\n        // },\r\n\r\n        _onDrag: function (e) {\r\n            var marker = this._marker,\r\n                /** @TODO use markerDragProto._onDrag */\r\n                rotated_marker = marker.options.rotation || marker.options.rotateWithView,\r\n                shadow = marker._shadow,\r\n                iconPos = L.DomUtil.getPosition(marker._icon);\r\n\r\n            /** @TODO use markerDragProto._onDrag */\r\n            // update shadow position\r\n            if (!rotated_marker && shadow) {\r\n                L.DomUtil.setPosition(shadow, iconPos);\r\n            }\r\n\r\n            /** @TODO use markerDragProto._onDrag */\r\n            if (marker._map._rotate) {\r\n                // Reverse calculation from mapPane coordinates to rotatePane coordinates\r\n                iconPos = marker._map.mapPanePointToRotatedPoint(iconPos);\r\n            }\r\n            var latlng = marker._map.layerPointToLatLng(iconPos);\r\n\r\n            marker._latlng = latlng;\r\n            e.latlng = latlng;\r\n            e.oldLatLng = this._oldLatLng;\r\n\r\n            /** @TODO use markerDragProto._onDrag */\r\n            if (rotated_marker) {\r\n                marker.setLatLng(latlng); // use `setLatLng` to presisit rotation. low efficiency\r\n            } else {\r\n                marker.fire('move', e); // `setLatLng` will trig 'move' event. we imitate here.\r\n            }\r\n\r\n            // @event drag: Event\r\n            // Fired repeatedly while the user drags the marker.\r\n            marker\r\n                .fire('drag', e);\r\n        },\r\n\r\n        _onDragEnd: function (e) {\r\n            if (this._marker._map._rotate) {\r\n                this._marker.update();\r\n            }\r\n            markerDragProto._onDragEnd.apply(this, arguments);\r\n        },\r\n\r\n    };\r\n\r\n    L.Marker.include({\r\n\r\n        /**\r\n         * Update L.Marker anchor position after the map\r\n         * is moved by calling `map.setBearing(theta)`\r\n         *\r\n         * @listens L.Map~rotate\r\n         */\r\n        getEvents: function () {\r\n            return L.extend(markerProto.getEvents.apply(this, arguments), { rotate: this.update });\r\n        },\r\n\r\n        _initInteraction: function () {\r\n            var ret = markerProto._initInteraction.apply(this, arguments);\r\n            if (this.dragging && this.dragging.enabled() && this._map && this._map._rotate) {\r\n                // L.Handler.MarkerDrag is used internally by L.Marker to make the markers draggable\r\n                markerDragProto = markerDragProto || Object.getPrototypeOf(this.dragging);\r\n                this.dragging.disable();\r\n                Object.assign(this.dragging, {\r\n                    // _onDragStart: MarkerDrag._onDragStart.bind(this.dragging),\r\n                    _onDrag: MarkerDrag._onDrag.bind(this.dragging),\r\n                    _onDragEnd: MarkerDrag._onDragEnd.bind(this.dragging),\r\n                });\r\n                this.dragging.enable();\r\n            }\r\n            return ret;\r\n        },\r\n\r\n        _setPos: function (pos) {\r\n\r\n            /** @TODO use markerProto._setPos */\r\n            if (this._map._rotate) {\r\n                pos = this._map.rotatedPointToMapPanePoint(pos);\r\n            }\r\n\r\n            /** @TODO use markerProto._setPos */\r\n            var bearing = this.options.rotation || 0;\r\n            if (this.options.rotateWithView) {\r\n                bearing += this._map._bearing;\r\n            }\r\n\r\n            /** @TODO use markerProto._setPos */\r\n            if (this._icon) {\r\n                L.DomUtil.setPosition(this._icon, pos, bearing, pos, this.options.scale);\r\n            }\r\n\r\n            /** @TODO use markerProto._setPos */\r\n            if (this._shadow) {\r\n                L.DomUtil.setPosition(this._shadow, pos, bearing, pos, this.options.scale);\r\n            }\r\n\r\n            this._zIndex = pos.y + this.options.zIndexOffset;\r\n\r\n            this._resetZIndex();\r\n        },\r\n\r\n        // _updateZIndex: function(offset) {\r\n        //     if (!this._map._rotate) {\r\n        //         return markerProto._updateZIndex.apply(this, arguments);\r\n        //     }\r\n        //     this._icon.style.zIndex = Math.round(this._zIndex + offset);\r\n        // },\r\n\r\n        setRotation: function (rotation) {\r\n            this.options.rotation = rotation;\r\n            this.update();\r\n        },\r\n\r\n    });\r\n\r\n    L.Marker.__leafletRotateInstalled = true;\r\n}\r\n","/**\r\n * @external L.GridLayer\r\n *\r\n * @see https://github.com/Leaflet/Leaflet/tree/v1.9.3/src/layer/tile/GridLayer.js\r\n */\r\n\r\nexport function installGridLayer(L) {\r\n    if (!L.GridLayer || L.GridLayer.__leafletRotateInstalled) {\r\n        return;\r\n    }\r\n\r\n    const gridLayerProto = L.extend({}, L.GridLayer.prototype);\r\n\r\n    L.GridLayer.include({\r\n\r\n        /**\r\n         * Redraw L.TileLayer bounds after the map is\r\n         * moved by just calling `map.setBearing(theta)`\r\n         *\r\n         * @listens L.Map~rotate\r\n         */\r\n        getEvents: function () {\r\n            var events = gridLayerProto.getEvents.apply(this, arguments);\r\n            if (this._map._rotate && !this.options.updateWhenIdle) {\r\n                if (!this._onRotate) {\r\n                    this._onRotate = L.Util.throttle(this._onMoveEnd, this.options.updateInterval, this);\r\n                }\r\n                events.rotate = this._onRotate;\r\n            }\r\n            return events;\r\n        },\r\n\r\n        _getTiledPixelBounds: function (center) {\r\n            if (!this._map._rotate) {\r\n                return gridLayerProto._getTiledPixelBounds.apply(this, arguments);\r\n            }\r\n\r\n            return this._map._getNewPixelBounds(center, this._tileZoom);\r\n        },\r\n\r\n    });\r\n\r\n    L.GridLayer.__leafletRotateInstalled = true;\r\n}\r\n","/**\r\n * @external L.Renderer\r\n *\r\n * @see https://github.com/Leaflet/Leaflet/tree/v1.9.3/src/layer/vector/Renderer.js\r\n */\r\n\r\nexport function installRenderer(L) {\r\n    if (!L.Renderer || L.Renderer.__leafletRotateInstalled) {\r\n        return;\r\n    }\r\n\r\n    const rendererProto = L.extend({}, L.Renderer.prototype);\r\n\r\n    L.Renderer.include({\r\n\r\n        /**\r\n         * Redraw L.Canvas and L.SVG renderer bounds after the\r\n         * map is moved by just calling `map.setBearing(theta)`\r\n         *\r\n         * @listens L.Map~rotate\r\n         */\r\n        getEvents: function () {\r\n            return L.extend(rendererProto.getEvents.apply(this, arguments), { rotate: this._update });\r\n        },\r\n\r\n        /**\r\n         * Fix for `map.flyTo()` when `false === map.options.zoomAnimation`\r\n         *\r\n         * @see https://github.com/Leaflet/Leaflet/pull/8794\r\n         */\r\n        onAdd: function () {\r\n            rendererProto.onAdd.apply(this, arguments);\r\n            if (L.version <= \"1.9.3\") {\r\n                // always keep transform-origin as 0 0\r\n                this._container.classList.add('leaflet-zoom-animated');\r\n            }\r\n        },\r\n\r\n        /**\r\n         * @FIXME layer drifts on `map.setZoom()` (eg. zoom during animation)\r\n         *\r\n         * the main cause seems to be related to `this._updateTransform(path._center, path._zoom))`\r\n         * and `this._topLeft = this._map.layerPointToLatLng(this._bounds.min);`\r\n         *\r\n         * @example\r\n         *   map.setZoom(2);\r\n         *   path._renderer._update();\r\n         *   path._renderer._updateTransform(path._renderer._center, path._renderer._zoom);\r\n         *\r\n         * @see https://github.com/Leaflet/Leaflet/pull/8794\r\n         * @see https://github.com/Leaflet/Leaflet/pull/8103\r\n         * @see https://github.com/Leaflet/Leaflet/issues/7466\r\n         *\r\n         * @TODO rechek this changes from leaflet@v1.9.3\r\n         *\r\n         * @see https://github.com/Leaflet/Leaflet/compare/v1.7.0...v1.9.3\r\n         */\r\n        _updateTransform: function (center, zoom) {\r\n            if (!this._map._rotate) {\r\n                return rendererProto._updateTransform.apply(this, arguments);\r\n            }\r\n            /**\r\n             * @FIXME see path._renderer._reset();\r\n             */\r\n            var scale = this._map.getZoomScale(zoom, this._zoom),\r\n                offset = this._map._latLngToNewLayerPoint(this._topLeft, zoom, center);\r\n\r\n            L.DomUtil.setTransform(this._container, offset, scale);\r\n\r\n        },\r\n\r\n        _update: function () {\r\n            if (!this._map._rotate) {\r\n                return rendererProto._update.apply(this, arguments);\r\n            }\r\n            // Update pixel bounds of renderer container (for positioning/sizing/clipping later)\r\n            // Subclasses are responsible of firing the 'update' event.\r\n            this._bounds = this._map._getPaddedPixelBounds(this.options.padding);\r\n            this._topLeft = this._map.layerPointToLatLng(this._bounds.min);\r\n            this._center = this._map.getCenter();\r\n            this._zoom = this._map.getZoom();\r\n        },\r\n\r\n    });\r\n\r\n    L.Renderer.__leafletRotateInstalled = true;\r\n}\r\n","/**\r\n * Rotates the map according to a smartphone's compass.\r\n *\r\n * @typedef L.Map.CompassBearing\r\n */\r\n\r\nexport function installCompassBearing(L) {\r\n    if (L.Map && L.Map.CompassBearing) {\r\n        return;\r\n    }\r\n\r\n    L.Map.CompassBearing = L.Handler.extend({\r\n\r\n        initialize: function (map) {\r\n            this._map = map;\r\n            /** @see https://caniuse.com/?search=DeviceOrientation */\r\n            if ('ondeviceorientationabsolute' in window) {\r\n                this.__deviceOrientationEvent = 'deviceorientationabsolute';\r\n            } else if ('ondeviceorientation' in window) {\r\n                this.__deviceOrientationEvent = 'deviceorientation';\r\n            }\r\n            this._throttled = L.Util.throttle(this._onDeviceOrientation, 100, this);\r\n        },\r\n\r\n        addHooks: function () {\r\n            if (this._map._rotate && this.__deviceOrientationEvent) {\r\n                L.DomEvent.on(window, this.__deviceOrientationEvent, this._throttled, this);\r\n            } else {\r\n                // L.Map.CompassBearing handler will be automatically\r\n                // disabled if device orientation is not supported.\r\n                this.disable();\r\n            }\r\n        },\r\n\r\n        removeHooks: function () {\r\n            if (this._map._rotate && this.__deviceOrientationEvent) {\r\n                L.DomEvent.off(window, this.__deviceOrientationEvent, this._throttled, this);\r\n            }\r\n        },\r\n\r\n        /**\r\n         * `DeviceOrientationEvent.absolute` - Indicates whether the device is providing absolute\r\n         *                                     orientation values (relatives to Magnetic North) or\r\n         *                                     using some arbitrary frame determined by the device.\r\n         *\r\n         * `DeviceOrientationEvent.alpha`    - Returns the rotation of the device around the Z axis;\r\n         *                                     that is, the number of degrees by which the device is\r\n         *                                     being twisted around the center of the screen.\r\n         *\r\n         * `window.orientation`              - Returns the screen orientation in degrees (in 90-degree increments)\r\n         *                                     of the viewport relative to the device's natural orientation.\r\n         *                                     Its only possible values are -90, 0, 90, and 180. Positive\r\n         *                                     values are counterclockwise; negative values are clockwise.\r\n         *\r\n         * @see https://developer.mozilla.org/en-US/docs/Web/API/DeviceOrientationEvent/absolute\r\n         * @see https://developer.mozilla.org/en-US/docs/Web/API/DeviceOrientationEvent/alpha\r\n         * @see https://developer.mozilla.org/en-US/docs/Web/API/Window/orientation\r\n         */\r\n        _onDeviceOrientation: function (e) {\r\n            var angle = e.webkitCompassHeading || e.alpha;\r\n            var deviceOrientation = 0;\r\n\r\n            // Safari iOS\r\n            if (!e.absolute && e.webkitCompassHeading) {\r\n                angle = 360 - angle;\r\n            }\r\n\r\n            // Older browsers\r\n            if (!e.absolute && 'undefined' !== typeof window.orientation) {\r\n                deviceOrientation = window.orientation;\r\n            }\r\n\r\n            this._map.setBearing(angle - deviceOrientation);\r\n        },\r\n\r\n    });\r\n\r\n    /**\r\n     * Add Compass bearing handler to L.Map (disabled unless `window.DeviceOrientationEvent` is set).\r\n     *\r\n     * @property {L.Map.CompassBearing} compassBearing\r\n     */\r\n    L.Map.addInitHook('addHandler', 'compassBearing', L.Map.CompassBearing);\r\n}\r\n","/**\r\n * Triggers `invalidateResize` when the map's DOM container mutates.\r\n *\r\n * @typedef L.Map.ContainerMutation\r\n */\r\n\r\n/**\r\n * @TODO check again this file after leaflet v1.9.3 (eg. L.Browser.mutation).\r\n * Mutation Observer support will likely be added by default in next releases.\r\n */\r\n\r\nexport function installContainerMutation(L) {\r\n    if (L.Map && L.Map.ContainerMutation) {\r\n        return;\r\n    }\r\n\r\n    L.Map.mergeOptions({\r\n\r\n        /**\r\n         * Whether the map uses mutation observers to\r\n         * detect changes in its container and trigger\r\n         * `invalidateSize`. Disabled by default due to\r\n         * support not being available in all web browsers.\r\n         *\r\n         * @type {Boolean}\r\n         *\r\n         * @see https://developer.mozilla.org/docs/Web/API/MutationObserver\r\n         */\r\n        trackContainerMutation: false\r\n\r\n    });\r\n\r\n    L.Map.ContainerMutation = L.Handler.extend({\r\n\r\n        addHooks: function () {\r\n            // if (!L.Browser.mutation) { return; }\r\n            if (!this._observer) {\r\n                this._observer = new MutationObserver(L.Util.bind(this._map.invalidateSize, this._map));\r\n            }\r\n            this._observer.observe(this._map.getContainer(), {\r\n                childList: false,\r\n                attributes: true,\r\n                characterData: false,\r\n                subtree: false,\r\n                attributeFilter: ['style']\r\n            });\r\n        },\r\n\r\n        removeHooks: function () {\r\n            // if (!L.Browser.mutation) { return; }\r\n            this._observer.disconnect();\r\n        },\r\n\r\n    });\r\n\r\n    /**\r\n     * Add Container mutation handler to L.Map (disabled unless `trackContainerMutation` is set).\r\n     *\r\n     * @property {L.Map.ContainerMutation} trackContainerMutation\r\n     */\r\n    L.Map.addInitHook('addHandler', 'trackContainerMutation', L.Map.ContainerMutation);\r\n}\r\n","/**\r\n * TouchGestures is both TouchZoom plus TouchRotate\r\n *\r\n * @see https://github.com/fnicollet/Leaflet/commit/a77af51a6b10f308d1b9a16552091d1d0aee8834\r\n * @see https://github.com/Leaflet/Leaflet/blob/v1.9.3/src/map/handler/Map.TouchZoom.js\r\n *\r\n * @typedef L.Map.TouchGestures\r\n */\r\n\r\nexport function installTouchGestures(L) {\r\n    if (L.Map && L.Map.TouchGestures) {\r\n        return;\r\n    }\r\n\r\n    L.Map.mergeOptions({\r\n\r\n        /**\r\n         * Set it to false if you don't want the map to\r\n         * zoom beyond min/max zoom and then bounce back\r\n         * when pinch-zooming.\r\n         *\r\n         * @type {Boolean}\r\n         */\r\n        bounceAtZoomLimits: true,\r\n\r\n    });\r\n\r\n    L.Map.TouchGestures = L.Handler.extend({\r\n\r\n        initialize: function (map) {\r\n            this._map = map;\r\n            this.rotate = !!this._map.options.touchRotate;\r\n            this.zoom = !!this._map.options.touchZoom;\r\n        },\r\n\r\n        addHooks: function () {\r\n            L.DomEvent.on(this._map._container, 'touchstart', this._onTouchStart, this);\r\n        },\r\n\r\n        removeHooks: function () {\r\n            L.DomEvent.off(this._map._container, 'touchstart', this._onTouchStart, this);\r\n        },\r\n\r\n        _onTouchStart: function (e) {\r\n            var map = this._map;\r\n\r\n            if (!e.touches || e.touches.length !== 2 || map._animatingZoom || this._zooming || this._rotating) { return; }\r\n\r\n            var p1 = map.mouseEventToContainerPoint(e.touches[0]),\r\n                p2 = map.mouseEventToContainerPoint(e.touches[1]),\r\n                vector = p1.subtract(p2);\r\n\r\n            this._centerPoint = map.getSize()._divideBy(2);\r\n            this._startLatLng = map.containerPointToLatLng(this._centerPoint);\r\n\r\n            if (this.zoom) {\r\n                if (map.options.touchZoom !== 'center') {\r\n                    this._pinchStartLatLng = map.containerPointToLatLng(p1.add(p2)._divideBy(2));\r\n                }\r\n                this._startDist = p1.distanceTo(p2);\r\n                this._startZoom = map.getZoom();\r\n                this._zooming = true;\r\n            } else {\r\n                this._zooming = false;\r\n            }\r\n\r\n            if (this.rotate) {\r\n                this._startTheta = Math.atan(vector.x / vector.y);\r\n                this._startBearing = map.getBearing();\r\n                if (vector.y < 0) { this._startBearing += 180; }\r\n                this._rotating = true;\r\n            } else {\r\n                this._rotating = false;\r\n            }\r\n\r\n            this._moved = false;\r\n\r\n            map._stop();\r\n\r\n            L.DomEvent\r\n                .on(document, 'touchmove', this._onTouchMove, this)\r\n                .on(document, 'touchend touchcancel', this._onTouchEnd, this);\r\n\r\n            L.DomEvent.preventDefault(e);\r\n        },\r\n\r\n        _onTouchMove: function (e) {\r\n            if (!e.touches || e.touches.length !== 2 || !(this._zooming || this._rotating)) { return; }\r\n\r\n            var map = this._map,\r\n                p1 = map.mouseEventToContainerPoint(e.touches[0]),\r\n                p2 = map.mouseEventToContainerPoint(e.touches[1]),\r\n                vector = p1.subtract(p2),\r\n                scale = p1.distanceTo(p2) / this._startDist,\r\n                delta;\r\n\r\n            if (this._rotating) {\r\n                var theta = Math.atan(vector.x / vector.y);\r\n                var bearingDelta = (theta - this._startTheta) * L.DomUtil.RAD_TO_DEG;\r\n                if (vector.y < 0) { bearingDelta += 180; }\r\n                if (bearingDelta) {\r\n                    /**\r\n                     * @TODO the pivot should be the last touch point,\r\n                     * but zoomAnimation manages to overwrite the rotate\r\n                     * pane position. Maybe related to #3529.\r\n                     *\r\n                     * @see https://github.com/Leaflet/Leaflet/pull/3529\r\n                     * @see https://github.com/fnicollet/Leaflet/commit/a77af51a6b10f308d1b9a16552091d1d0aee8834\r\n                     */\r\n                    map.setBearing(this._startBearing - bearingDelta);\r\n                }\r\n            }\r\n\r\n            if (this._zooming) {\r\n                this._zoom = map.getScaleZoom(scale, this._startZoom);\r\n\r\n                if (!map.options.bounceAtZoomLimits && (\r\n                    (this._zoom < map.getMinZoom() && scale < 1) ||\r\n                    (this._zoom > map.getMaxZoom() && scale > 1))) {\r\n                    this._zoom = map._limitZoom(this._zoom);\r\n                }\r\n\r\n                if (map.options.touchZoom === 'center') {\r\n                    this._center = this._startLatLng;\r\n                    if (scale === 1) { return; }\r\n                } else {\r\n                    // Get delta from pinch to center, so centerLatLng is delta applied to initial pinchLatLng\r\n                    delta = p1._add(p2)._divideBy(2)._subtract(this._centerPoint);\r\n                    if (scale === 1 && delta.x === 0 && delta.y === 0) { return; }\r\n\r\n                    var alpha = -map.getBearing() * L.DomUtil.DEG_TO_RAD;\r\n\r\n                    this._center = map.unproject(map.project(this._pinchStartLatLng).subtract(delta.rotate(alpha)));\r\n                }\r\n\r\n            }\r\n\r\n            if (!this._moved) {\r\n                map._moveStart(true, false);\r\n                this._moved = true;\r\n            }\r\n\r\n            L.Util.cancelAnimFrame(this._animRequest);\r\n\r\n            var moveFn = map._move.bind(map, this._center, this._zoom, { pinch: true, round: false }, undefined);\r\n            this._animRequest = L.Util.requestAnimFrame(moveFn, this, true);\r\n\r\n            L.DomEvent.preventDefault(e);\r\n        },\r\n\r\n        _onTouchEnd: function () {\r\n            if (!this._moved || !(this._zooming || this._rotating)) {\r\n                this._zooming = false;\r\n                return;\r\n            }\r\n\r\n            this._zooming = false;\r\n            this._rotating = false;\r\n            L.Util.cancelAnimFrame(this._animRequest);\r\n\r\n            L.DomEvent\r\n                .off(document, 'touchmove', this._onTouchMove, this)\r\n                .off(document, 'touchend touchcancel', this._onTouchEnd, this);\r\n\r\n            if (this.zoom) {\r\n                // Pinch updates GridLayers' levels only when zoomSnap is off, so zoomSnap becomes noUpdate.\r\n                if (this._map.options.zoomAnimation) {\r\n                    this._map._animateZoom(this._center, this._map._limitZoom(this._zoom), true, this._map.options.zoomSnap);\r\n                } else {\r\n                    this._map._resetView(this._center, this._map._limitZoom(this._zoom));\r\n                }\r\n            }\r\n        },\r\n\r\n    });\r\n\r\n    /**\r\n     * Add Touch Gestures handler (enabled unless `touchGestures` is unset).\r\n     *\r\n     * @property {L.Map.TouchGestures} touchGestures\r\n     */\r\n    L.Map.addInitHook('addHandler', 'touchGestures', L.Map.TouchGestures);\r\n}\r\n","/**\r\n * Rotates the map on two-finger (touch devices).\r\n *\r\n * @typedef L.Map.TouchRotate\r\n */\r\n\r\nexport function installTouchRotate(L) {\r\n    if (L.Map && L.Map.TouchRotate) {\r\n        return;\r\n    }\r\n\r\n    L.Map.mergeOptions({\r\n\r\n        /**\r\n         * Whether the map can be rotated with a two-finger rotation gesture\r\n         *\r\n         * @type {Boolean}\r\n         */\r\n        touchRotate: false,\r\n\r\n    });\r\n\r\n    L.Map.TouchRotate = L.Handler.extend({\r\n\r\n        addHooks: function () {\r\n            this._map.touchGestures.enable();\r\n            this._map.touchGestures.rotate = true;\r\n        },\r\n\r\n        removeHooks: function () {\r\n            this._map.touchGestures.rotate = false;\r\n        },\r\n\r\n    });\r\n\r\n    /**\r\n     * Add Touch Rotate handler (disabled unless `touchGestures` is set).\r\n     *\r\n     * @property {L.Map.TouchGestures} touchGestures\r\n     */\r\n    L.Map.addInitHook('addHandler', 'touchRotate', L.Map.TouchRotate);\r\n}\r\n","\r\n/**\r\n * Rotates the map on shift key + mousewheel scrolling (desktop).\r\n *\r\n * @typedef L.Map.ShiftKeyRotate\r\n */\r\n\r\nexport function installShiftKeyRotate(L) {\r\n    if (L.Map && L.Map.ShiftKeyRotate) {\r\n        return;\r\n    }\r\n\r\n    L.Map.mergeOptions({\r\n\r\n        /**\r\n         * Whether the map can be rotated with shift + wheel scroll\r\n         * @type {Boolean}\r\n         */\r\n        shiftKeyRotate: true,\r\n\r\n    });\r\n\r\n    L.Map.ShiftKeyRotate = L.Handler.extend({\r\n\r\n        addHooks: function () {\r\n            L.DomEvent.on(this._map._container, \"wheel\", this._handleShiftScroll, this);\r\n            // this._map.shiftKeyRotate.enable();\r\n            this._map.shiftKeyRotate.rotate = true;\r\n        },\r\n\r\n        removeHooks: function () {\r\n            L.DomEvent.off(this._map._container, \"wheel\", this._handleShiftScroll, this);\r\n            this._map.shiftKeyRotate.rotate = false;\r\n        },\r\n\r\n        _handleShiftScroll: function (e) {\r\n            if (e.shiftKey) {\r\n                e.preventDefault();\r\n                this._map.scrollWheelZoom.disable();\r\n                this._map.setBearing((this._map._bearing * L.DomUtil.RAD_TO_DEG) + Math.sign(e.deltaY) * 5);\r\n            } else {\r\n                this._map.scrollWheelZoom.enable();\r\n            }\r\n        },\r\n\r\n    });\r\n\r\n    /**\r\n     * Add ShiftKey handler to L.Map (enabled unless `shiftKeyRotate` is unset).\r\n     *\r\n     * @property {L.Map.ShiftKeyRotate} shiftKeyRotate\r\n     */\r\n    L.Map.addInitHook('addHandler', 'shiftKeyRotate', L.Map.ShiftKeyRotate);\r\n\r\n    // decrease `scrollWheelZoom` handler priority over `shiftKeyRotate` handler\r\n    L.Map.addInitHook(function () {\r\n        if (this.scrollWheelZoom.enabled() && this.shiftKeyRotate.enabled()) {\r\n            this.scrollWheelZoom.disable();\r\n            this.scrollWheelZoom.enable();\r\n        }\r\n    });\r\n}\r\n","/**\r\n * Adds pinch zoom rotation on mobile browsers\r\n *\r\n * @see https://github.com/Leaflet/Leaflet/blob/v1.9.3/src/map/handler/Map.TouchZoom.js\r\n *\r\n * @external L.Map.TouchZoom\r\n */\r\n\r\nexport function installTouchZoom(L) {\r\n    if (L.Map && L.Map.TouchZoom) {\r\n        return;\r\n    }\r\n\r\n    L.Map.mergeOptions({\r\n\r\n        /**\r\n         * Whether the map can be zoomed by touch-dragging\r\n         * with two fingers. If passed `'center'`, it will\r\n         * zoom to the center of the view regardless of\r\n         * where the touch events (fingers) were. Enabled\r\n         * for touch-capable web browsers.\r\n         *\r\n         * @type {(Boolean|String)}\r\n         */\r\n        touchZoom: L.Browser.touch,\r\n\r\n        /**\r\n         * @TODO check if this is a duplicate of `L.Map.TouchGestures::bounceAtZoomLimits`\r\n         *\r\n         * Set it to false if you don't want the map to\r\n         * zoom beyond min/max zoom and then bounce back\r\n         * when pinch-zooming.\r\n         *\r\n         * @type {Boolean}\r\n         */\r\n        bounceAtZoomLimits: false,\r\n\r\n    });\r\n\r\n    L.Map.TouchZoom = L.Handler.extend({\r\n\r\n        addHooks: function () {\r\n            L.DomUtil.addClass(this._map._container, 'leaflet-touch-zoom');\r\n            this._map.touchGestures.enable();\r\n            this._map.touchGestures.zoom = true;\r\n        },\r\n\r\n        removeHooks: function () {\r\n            L.DomUtil.removeClass(this._map._container, 'leaflet-touch-zoom');\r\n            this._map.touchGestures.zoom = false;\r\n        },\r\n\r\n    });\r\n\r\n    /**\r\n     * Add Touch Zoom handler (disabled unless `L.Browser.touch` is set).\r\n     *\r\n     * @property {L.Map.TouchGestures} touchGestures\r\n     */\r\n    L.Map.addInitHook('addHandler', 'touchZoom', L.Map.TouchZoom);\r\n}\r\n","/**\r\n * A tri-state control for map rotation, states are:\r\n *\r\n * - Locked (default)\r\n * - Unlocked (user can pinch-rotate)\r\n * - Follow (rotation follows device orientation, if available)\r\n *\r\n * @typedef L.Control.Rotate\r\n */\r\n\r\nexport function installRotateControl(L) {\r\n    if (L.Control && L.Control.Rotate) {\r\n        return;\r\n    }\r\n\r\n    L.Control.Rotate = L.Control.extend({\r\n\r\n        options: {\r\n            position: 'topleft',\r\n            closeOnZeroBearing: true\r\n        },\r\n\r\n        onAdd: function (map) {\r\n            var container = this._container = L.DomUtil.create('div', 'leaflet-control-rotate leaflet-bar');\r\n\r\n            // this.button = L.Control.Zoom.prototype._createButton.call(this, 'R', 'leaflet-control-rotate', 'leaflet-control-rotate', container, this._toggleLock);\r\n\r\n            var arrow = this._arrow = L.DomUtil.create('span', 'leaflet-control-rotate-arrow');\r\n\r\n            arrow.style.backgroundImage = `url(\"data:image/svg+xml;charset=utf-8,%3Csvg width='29' height='29' viewBox='0 0 29 29' xmlns='http://www.w3.org/2000/svg' fill='%23333'%3E%3Cpath d='M10.5 14l4-8 4 8h-8z'/%3E%3Cpath d='M10.5 16l4 8 4-8h-8z' fill='%23ccc'/%3E%3C/svg%3E\")`;\r\n            arrow.style.cursor = 'grab';\r\n            arrow.style.display = 'block';\r\n            arrow.style.width = '100%';\r\n            arrow.style.height = '100%';\r\n            arrow.style.backgroundRepeat = 'no-repeat';\r\n            arrow.style.backgroundPosition = '50%';\r\n\r\n            // Copy-pasted from L.Control.Zoom\r\n            var link = this._link = L.DomUtil.create('a', 'leaflet-control-rotate-toggle', container);\r\n            link.appendChild(arrow);\r\n            link.href = '#';\r\n            link.title = 'Rotate map';\r\n\r\n            L.DomEvent\r\n                .on(link, 'dblclick', L.DomEvent.stopPropagation)\r\n                .on(link, 'mousedown', this._handleMouseDown, this)\r\n                .on(link, 'click', L.DomEvent.stop)\r\n                .on(link, 'click', this._cycleState, this)\r\n                .on(link, 'click', this._refocusOnMap, this);\r\n\r\n            if (!L.Browser.any3d) {\r\n                L.DomUtil.addClass(link, 'leaflet-disabled');\r\n            }\r\n\r\n            this._restyle();\r\n\r\n            map.on('rotate', this._restyle, this);\r\n\r\n            // State flag\r\n            this._follow = false;\r\n            this._canFollow = false;\r\n\r\n            if (this.options.closeOnZeroBearing && map.getBearing() === 0) {\r\n                container.style.display = 'none';\r\n            }\r\n\r\n            return container;\r\n        },\r\n\r\n        onRemove: function (map) {\r\n            map.off('rotate', this._restyle, this);\r\n        },\r\n\r\n        _handleMouseDown: function (e) {\r\n            L.DomEvent.stop(e);\r\n            this.dragging = true;\r\n            this.dragstartX = e.pageX;\r\n            this.dragstartY = e.pageY;\r\n            L.DomEvent\r\n                .on(document, 'mousemove', this._handleMouseDrag, this)\r\n                .on(document, 'mouseup', this._handleMouseUp, this);\r\n        },\r\n\r\n        _handleMouseUp: function (e) {\r\n            L.DomEvent.stop(e);\r\n            this.dragging = false;\r\n\r\n            L.DomEvent\r\n                .off(document, 'mousemove', this._handleMouseDrag, this)\r\n                .off(document, 'mouseup', this._handleMouseUp, this);\r\n        },\r\n\r\n        _handleMouseDrag: function (e) {\r\n            if (!this.dragging) { return; }\r\n            var deltaX = e.clientX - this.dragstartX;\r\n            this._map.setBearing(deltaX);\r\n        },\r\n\r\n        _cycleState: function (ev) {\r\n            if (!this._map) {\r\n                return;\r\n            }\r\n\r\n            var map = this._map;\r\n\r\n            // Touch mode\r\n            if (!map.touchRotate.enabled() && !map.compassBearing.enabled()) {\r\n                map.touchRotate.enable();\r\n            }\r\n\r\n            // Compass mode\r\n            else if (!map.compassBearing.enabled()) {\r\n                map.touchRotate.disable();\r\n                (\r\n                    DeviceOrientationEvent && DeviceOrientationEvent.requestPermission\r\n                        ? DeviceOrientationEvent.requestPermission() // iOS compass\r\n                        : Promise.resolve('granted')                 // others\r\n                ).then(state => \"granted\" === state && map.compassBearing.enable())\r\n            }\r\n\r\n            // Locked mode\r\n            else {\r\n                map.compassBearing.disable();\r\n                map.setBearing(0);\r\n                if (this.options.closeOnZeroBearing) {\r\n                    map.touchRotate.enable();\r\n                }\r\n            }\r\n            this._restyle();\r\n        },\r\n\r\n        _restyle: function () {\r\n            if (!this._map.options.rotate) {\r\n                L.DomUtil.addClass(this._link, 'leaflet-disabled');\r\n            } else {\r\n                var map = this._map;\r\n                var bearing = map.getBearing();\r\n\r\n                this._arrow.style.transform = 'rotate(' + bearing + 'deg)';\r\n\r\n                if (bearing && this.options.closeOnZeroBearing) {\r\n                    this._container.style.display = 'block';\r\n                }\r\n\r\n                // Compass mode\r\n                if (map.compassBearing.enabled()) {\r\n                    this._link.style.backgroundColor = 'orange';\r\n                }\r\n\r\n                // Touch mode\r\n                else if (map.touchRotate.enabled()) {\r\n                    this._link.style.backgroundColor = null;\r\n                }\r\n\r\n                // Locked mode\r\n                else {\r\n                    this._link.style.backgroundColor = 'grey';\r\n                    if (0 === bearing && this.options.closeOnZeroBearing) {\r\n                        this._container.style.display = 'none';\r\n                    }\r\n                }\r\n            }\r\n        },\r\n\r\n    });\r\n\r\n    L.control.rotate = function (options) {\r\n        return new L.Control.Rotate(options);\r\n    };\r\n\r\n    L.Map.mergeOptions({\r\n        rotateControl: true,\r\n    });\r\n\r\n    L.Map.addInitHook(function () {\r\n        if (this.options.rotateControl) {\r\n            var options = typeof this.options.rotateControl === 'object' ? this.options.rotateControl : {};\r\n            this.rotateControl = L.control.rotate(options);\r\n            this.addControl(this.rotateControl);\r\n        }\r\n    });\r\n}\r\n"],"names":["install","L","Error","Point","__leafletRotateInstalled","extend","prototype","rotate","theta","this","rotateFrom","pivot","sinTheta","Math","sin","cosTheta","cos","cx","x","cy","y","installPoint","DomUtil","domUtilProto","setTransform","el","offset","scale","bearing","pos","_round","apply","arguments","style","TRANSFORM","setPosition","point","_leaflet_pos","Browser","any3d","left","top","DEG_TO_RAD","PI","RAD_TO_DEG","installDomUtil","Draggable","include","installDraggable","Map","mapProto","mergeOptions","initialize","id","options","_rotate","_bearing","setBearing","containerPointToLayerPoint","subtract","_getMapPanePos","_getRotatePanePos","layerPointToContainerPoint","add","rotatedPointToMapPanePoint","_add","mapPanePointToRotatedPoint","_subtract","mapBoundsToContainerBounds","bounds","origin","getPixelOrigin","nw","project","getNorthWest","ne","getNorthEast","sw","getSouthWest","se","getSouthEast","min","max","getBounds","size","getSize","LatLngBounds","containerPointToLatLng","Util","wrapNum","center","_getPixelCenter","oldPos","newPos","_rotatePane","_pivot","_rotatePanePos","fire","getBearing","_initPanes","panes","_panes","_paneRenderers","_mapPane","createPane","_container","_norotatePane","markerZoomAnimation","addClass","markerPane","shadowPane","panInside","latlng","abs","toFixed","paddingTL","paddingTopLeft","padding","paddingBR","paddingBottomRight","rect","getBoundingClientRect","pixelPoint","latLngToContainerPoint","pixelBounds","pixelCenter","getCenter","paddedBounds","paddedSize","contains","_enforcingBounds","centerOffset","panTo","getBoundsZoom","inside","latLngBounds","zoom","getZoom","getMinZoom","getMaxZoom","boundsSize","snap","zoomSnap","scalex","scaley","getScaleZoom","round","ceil","floor","_getCenterOffset","_getNewPixelOrigin","viewHalf","_divideBy","_getNewPixelBounds","mapZoom","_animatingZoom","_animateToZoom","getZoomScale","halfSize","Bounds","divideBy","_getPaddedPixelBounds","p","padMin","multiplyBy","padMax","_handleGeolocationResponse","_leaflet_id","lat","coords","latitude","lng","longitude","hdg","heading","LatLng","toBounds","accuracy","_locateOptions","setView","maxZoom","data","timestamp","i","installMap","DivOverlay","divOverlayProto","getEvents","_updatePosition","_map","_zoomAnimated","anchor","_getAnchor","getPosition","installDivOverlay","Popup","popupProto","_animateZoom","e","_adjustPan","autoPan","_panAnim","_inProgress","_autopanning","map","marginBottom","parseInt","getStyle","containerHeight","offsetHeight","containerWidth","_containerWidth","layerPos","_containerLeft","_containerBottom","containerPos","autoPanPadding","autoPanPaddingTopLeft","autoPanPaddingBottomRight","dx","dy","keepInView","panBy","installPopup","Tooltip","tooltipProto","_latLngToNewLayerPoint","_latlng","_setPosition","latLngToLayerPoint","installTooltip","Icon","_setIconStyles","img","name","sizeOption","shadowAnchor","iconAnchor","className","marginLeft","marginTop","width","height","installMarkerIcon","Marker","markerProto","markerDragProto","rotation","rotateWithView","undefined","MarkerDrag","_onDrag","marker","_marker","rotated_marker","shadow","_shadow","iconPos","_icon","layerPointToLatLng","oldLatLng","_oldLatLng","setLatLng","_onDragEnd","update","_initInteraction","ret","dragging","enabled","Object","getPrototypeOf","disable","assign","bind","enable","_setPos","_zIndex","zIndexOffset","_resetZIndex","setRotation","installMarker","GridLayer","gridLayerProto","events","updateWhenIdle","_onRotate","throttle","_onMoveEnd","updateInterval","_getTiledPixelBounds","_tileZoom","installGridLayer","Renderer","rendererProto","_update","onAdd","version","classList","_updateTransform","_zoom","_topLeft","_bounds","_center","installRenderer","CompassBearing","Handler","window","__deviceOrientationEvent","_throttled","_onDeviceOrientation","addHooks","DomEvent","on","removeHooks","off","angle","webkitCompassHeading","alpha","deviceOrientation","absolute","orientation","addInitHook","installCompassBearing","ContainerMutation","trackContainerMutation","_observer","MutationObserver","invalidateSize","observe","getContainer","childList","attributes","characterData","subtree","attributeFilter","disconnect","installContainerMutation","TouchGestures","bounceAtZoomLimits","touchRotate","touchZoom","_onTouchStart","touches","length","_zooming","_rotating","p1","mouseEventToContainerPoint","p2","vector","_centerPoint","_startLatLng","_pinchStartLatLng","_startDist","distanceTo","_startZoom","_startTheta","atan","_startBearing","_moved","_stop","document","_onTouchMove","_onTouchEnd","preventDefault","delta","bearingDelta","_limitZoom","unproject","_moveStart","cancelAnimFrame","_animRequest","moveFn","_move","pinch","requestAnimFrame","zoomAnimation","_resetView","installTouchGestures","TouchRotate","touchGestures","installTouchRotate","ShiftKeyRotate","shiftKeyRotate","_handleShiftScroll","shiftKey","scrollWheelZoom","sign","deltaY","installShiftKeyRotate","TouchZoom","touch","removeClass","installTouchZoom","Control","Rotate","position","closeOnZeroBearing","container","create","arrow","_arrow","backgroundImage","cursor","display","backgroundRepeat","backgroundPosition","link","_link","appendChild","href","title","stopPropagation","_handleMouseDown","stop","_cycleState","_refocusOnMap","_restyle","_follow","_canFollow","onRemove","dragstartX","pageX","dragstartY","pageY","_handleMouseDrag","_handleMouseUp","deltaX","clientX","ev","compassBearing","DeviceOrientationEvent","requestPermission","Promise","resolve","then","state","transform","backgroundColor","control","rotateControl","addControl","installRotateControl","index"],"mappings":"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"}